GLchar const* s_szPasstrough_vertex_shader_v110 =
"#version 110															\n"
"uniform vec4 offsScale;												\n"
"void main()															\n"
"{																		\n"
"	gl_Position=gl_Vertex;												\n"
"	gl_TexCoord[0]=gl_MultiTexCoord0;									\n"
"	gl_TexCoord[0].x-=offScale.x;		    							\n"
"	gl_TexCoord[0].y-=offScale.y;		    							\n"
"	gl_TexCoord[0].x*=offScale.z;		    							\n"
"	gl_TexCoord[0].x*=offScale.w;		    							\n"
"}																		\n";

GLchar const* s_szPasstrough_vertex_shader_v330 =
"#version 330															\n"
"in vec2 TexCoord;														\n"
"in vec3 Position;														\n"
"																		\n"
"out vec2 texcoord;														\n"
"																		\n"
"const vec2 pos[4] =													\n"
"vec2[4](																		\n"
"	vec2(-1.0, 1.0),													\n"
"	vec2(-1.0,-1.0),													\n"
"	vec2( 1.0, 1.0),													\n"
"	vec2( 1.0,-1.0)														\n"
");																		\n"
"																		\n"
"const vec2 tex[4] = 													\n"
"vec2[4](																\n"
"	vec2(0,0),															\n"
"	vec2(0,1),															\n"
"	vec2(1,0),															\n"
"	vec2(1,1)															\n"
");																		\n"
"																		\n"
"uniform vec4 offsScale;												\n" //sth. to do with "partial input"; fefault is (0,0,1,1)
"uniform vec4 size;														\n"	// weird: size = (viewportsize.xy, 1/viewportsize.xy)
"																		\n"
"void main(void) {														\n"
"	gl_Position =														\n"    //transform from [-1,+1] to [sigthly less then -1, slightly more than +1], 
"		vec4( (pos[gl_VertexID].x + pos[gl_VertexID].x * size.x) * size.z, \n" //  make slightly bigger, namely by inverse viewport size
"             (pos[gl_VertexID].y + pos[gl_VertexID].y * size.y) * size.w, \n"
"             0.0, 1.0);												\n"
"																		\n"
"	texcoord = tex[gl_VertexID];										\n"
"	texcoord-= offsScale.xy; 											\n"
"	texcoord*= offsScale.zw; 											\n"
"}																		\n";
//"	gl_Position = vec4(pos[gl_VertexID], 0.0, 1.0);\n"


GLchar const* s_fragment_shader_header_v110 =
"#version 110															\n"
"uniform sampler2D samContent, samWarp, samBlend;						\n"
"uniform bool bBorder;													\n"
"uniform bool bDoNotBlend;												\n"
"uniform mat4 matView;													\n"
"#define texcoord gl_TexCoord[0]										\n"
"#define FragColor gl_FragColor											\n"
"vec4 _tex2D( sampler2D sam, vec2 tex ){ return texture2D( sam, tex ); } \n";

GLchar const* s_fragment_shader_header_v330 =
"#version 330															\n"
"uniform sampler2D samContent, samWarp, samBlend;						\n"
"uniform bool bBorder;													\n"
"uniform bool bDoNotBlend;												\n"
"uniform mat4 matView;													\n"
"in vec2 texcoord;														\n"
"out vec4 FragColor;													\n"
"vec4 _tex2D( sampler2D sam, vec2 tex ){ return texture( sam, tex ); }   \n";

GLchar const* s_func_tex2D_BC = 
"uniform vec4 params;													\n"
"vec4 _texture2D( sampler2D texCnt,										\n"
"				   vec2 vPos)											\n"
"{																		\n"
"	vPos*= params.xy;													\n"
"	vec2 t = floor( vPos - 0.5 ) + vec2(0.5,0.5); // the nearest pixel	\n"
"	vec2 w0 = vec2(1,1);												\n"
"	vec2 w1 = vPos - t;													\n"
"	vec2 w2 = w1 * w1;													\n"
"	vec2 w3 = w2 * w1;													\n"
"																		\n"
"	w0 = w2 - 0.5 * (w3 + w1);											\n"
"	w1 = 1.5 * w3 - 2.5 * w2 + 1.0;										\n"
"	w3 = 0.5 * (w3 - w2);												\n"
"	w2 = 1.0 - w0 - w1 - w3;											\n"
"																		\n"
"	vec2 s0 = w0 + w1;													\n"
"	vec2 s1 = w2 + w3;													\n"
"	vec2 f0 = w1 / s0;													\n"
"	vec2 f1 = w3 / s1;													\n"
"																		\n"
"	vec2 t0 = t - 1.0 + f0;												\n"
"	vec2 t1 = t + 1.0 + f1;												\n"
"	t0*= params.zw;														\n"
"	t1*= params.zw;														\n"
"																		\n"
"	return																\n"
"		( _tex2D( texCnt, t0 ) * s0.x +								\n"
"		  _tex2D( texCnt, vec2( t1.x, t0.y ) ) * s1.x ) * s0.y +		\n"
"		( _tex2D( texCnt, vec2( t0.x, t1.y ) ) * s0.x +				\n"
"		  _tex2D( texCnt, t1 ) * s1.x ) * s1.y;						\n"
"}																		\n";

GLchar const* s_func_tex2D = 
"vec4 _texture2D( sampler2D texCnt,										\n"
"				   vec2 vPos)											\n"
"{																		\n"
"	return _tex2D( texCnt, vPos );									\n"
"}																		\n";

GLchar const* s_bypass_fragment_shader = 
"void main()															\n"
"{																		\n"
"	FragColor = _texture2D( samContent,texcoord.st );			\n"
"	FragColor.a = 1.0;												\n"
"}																		\n";

GLchar const* s_warp_blend_fragment_shader = 
"void main()\n"
"{																		\n"
"	vec4 tex = _tex2D( samWarp,texcoord.st );						\n"
"	vec4 blend = _tex2D( samBlend, texcoord.st );					\n"
"	if( blend.a > 0.1 )											      \n"
"	{																	\n"
"		tex.y = 1.0 - tex.y;											\n"
"		if( bBorder )													\n"
"		{																\n"
"		    tex.x*= 1.02;												\n"
"		    tex.x-= 0.01;												\n"
"		    tex.y*= 1.02;												\n"
"		    tex.y-= 0.01;												\n"
"		}																\n"
"		tex.xy/= blend.a;													\n"
"		FragColor = _texture2D( samContent, tex.xy );					\n"
"		if( !bDoNotBlend )												\n"
"			FragColor.rgb*= blend.rgb;									\n"
"		FragColor.a = 1.0;												\n"
"	}																	\n"
"	else																\n"	
"	{																	\n"
"		FragColor = blend; //vec4( 0.0,0.0,1.0,1.0 );							\n"  //HACK TEST blue debug color
"	}																	\n"
"}																		\n";
                                                                        
GLchar const* s_warp_blend_fragment_shader_3D = 						
"void main()															\n"
"{                                               						\n"
"	vec4 tex = _tex2D( samWarp, texcoord.st );     					\n"
"	vec4 blend = _tex2D( samBlend, texcoord.st );  					\n"
"	if( blend.a > 0.1 )                            						\n"
"	{                                           						\n"
"		tex/= blend.a;                            						\n"
"		tex.a = 1;                            						\n"
"		tex = matView * tex;                    						\n"
"		tex.xy/= tex.w;                         						\n"
"		tex.x/=2.0;                              						\n"
"		tex.y/=2.0;                              						\n"
"		tex.xy+= 0.5;                           						\n"
"		FragColor = _texture2D( samContent, tex.xy );	 				\n"
"		if( !bDoNotBlend )												\n"
"			FragColor.rgb*= blend.rgb;									\n"
"		FragColor.a = 1.0;               								\n"
"	}                                           						\n"
"	else																\n"
"	{																	\n"
"		FragColor = vec4( 0.0,1.0,0.0,1.0 );							\n" //HACK TEST green debug color
"	}																	\n"
"}																		\n";
